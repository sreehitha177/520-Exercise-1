**Codes Generated by Chat GPT COT**

# =========================
# Problem 1: odd_Num_Sum
# =========================
odd_Num_Sum_solutions = [
"""
def odd_Num_Sum(n):
    return sum((2 * i - 1) ** 5 for i in range(1, n + 1))
""",
"""
def odd_Num_Sum(n):
    total = 0
    for i in range(1, n * 2, 2):
        total += i ** 5
    return total
""",
"""
def odd_Num_Sum(n):
    odds = [x for x in range(1, 2 * n, 2)]
    return sum(pow(x, 5) for x in odds)
""",
"""
def odd_Num_Sum(n):
    return sum(map(lambda x: (2 * x - 1) ** 5, range(1, n + 1)))
""",
"""
def odd_Num_Sum(n):
    return sum([(2*i-1)**5 for i in range(1,n+1)])
"""
]

# =========================
# Problem 2: cal_electbill
# =========================
cal_electbill_solutions = [
"""
def cal_electbill(units):
    if units <= 100:
        return units * 1.5
    elif units <= 200:
        return 100 * 1.5 + (units - 100) * 2.5
    elif units <= 500:
        return 100 * 1.5 + 100 * 2.5 + (units - 200) * 4
    else:
        return 100 * 1.5 + 100 * 2.5 + 300 * 4 + (units - 500) * 6
""",
"""
def cal_electbill(units):
    slabs = [(100, 1.5), (100, 2.5), (300, 4), (float('inf'), 6)]
    total = 0
    for limit, rate in slabs:
        if units > limit:
            total += limit * rate
            units -= limit
        else:
            total += units * rate
            break
    return total
""",
"""
def cal_electbill(units):
    bill = 0
    if units > 500:
        bill += (units - 500) * 6
        units = 500
    if units > 200:
        bill += (units - 200) * 4
        units = 200
    if units > 100:
        bill += (units - 100) * 2.5
        units = 100
    bill += units * 1.5
    return bill
""",
"""
def cal_electbill(units):
    thresholds = [100, 200, 500]
    rates = [1.5, 2.5, 4, 6]
    if units <= thresholds[0]:
        return units * rates[0]
    elif units <= thresholds[1]:
        return 100 * rates[0] + (units - 100) * rates[1]
    elif units <= thresholds[2]:
        return 100 * rates[0] + 100 * rates[1] + (units - 200) * rates[2]
    else:
        return 100 * rates[0] + 100 * rates[1] + 300 * rates[2] + (units - 500) * rates[3]
""",
"""
def cal_electbill(units):
    if units <= 100:
        return units * 1.5
    elif units <= 200:
        return 150 + (units-100)*2.5
    elif units <= 500:
        return 150 + 250 + (units-200)*4
    else:
        return 150+250+1200+(units-500)*6
"""
]

# =========================
# Problem 3: check
# =========================
check_solutions = [
"""
def check(num):
    rev = int(str(num)[::-1])
    return num == 2 * rev - 1
""",
"""
def check(num):
    return num + 1 == 2 * int(str(num)[::-1])
""",
"""
def check(num):
    rev = int(''.join(reversed(str(num))))
    return (2 * rev) - 1 == num
""",
"""
def check(num):
    s = str(num)
    r = int(s[::-1])
    return (num - (2 * r - 1)) == 0
""",
"""
def check(num):
    return int(str(num)[::-1])*2-1 == num
"""
]

# =========================
# Problem 4: count_variable
# =========================
count_variable_solutions = [
"""
from collections import Counter
def count_variable(lst):
    c = Counter(lst)
    res = []
    for k, v in c.items():
        res.extend([k] * v)
    return res
""",
"""
def count_variable(lst):
    return [x for x in lst for _ in range(lst.count(x))]
""",
"""
def count_variable(lst):
    d = {}
    for item in lst:
        d[item] = d.get(item, 0) + 1
    out = []
    for k, v in d.items():
        out += [k] * v
    return out
""",
"""
def count_variable(lst):
    return sum(([x] * lst.count(x) for x in dict.fromkeys(lst)), [])
""",
"""
def count_variable(lst):
    from collections import Counter
    res = []
    for k,v in Counter(lst).items():
        res+=[k]*v
    return res
"""
]

# =========================
# Problem 5: find_tuples
# =========================
find_tuples_solutions = [
"""
def find_tuples(lst, k):
    return [t for t in lst if all(x % k == 0 for x in t)]
""",
"""
def find_tuples(lst, k):
    res = []
    for tup in lst:
        if all(elem % k == 0 for elem in tup):
            res.append(tup)
    return res
""",
"""
def find_tuples(lst, k):
    return list(filter(lambda t: all(i % k == 0 for i in t), lst))
""",
"""
def find_tuples(lst, k):
    out = []
    for t in lst:
        divisible = True
        for e in t:
            if e % k != 0:
                divisible = False
                break
        if divisible:
            out.append(t)
    return out
""",
"""
def find_tuples(lst, k):
    return [t for t in lst if min(t)%k==0]
"""
]

# =========================
# Problem 6: ap_sum
# =========================
ap_sum_solutions = [
"""
def ap_sum(a, d, n):
    return n * (2 * a + (n - 1) * d) // 2
""",
"""
def ap_sum(a, d, n):
    total = 0
    for i in range(n):
        total += a + i * d
    return total
""",
"""
def ap_sum(a, d, n):
    return sum(a + i * d for i in range(n))
""",
"""
def ap_sum(a, d, n):
    last = a + (n - 1) * d
    return n * (a + last) // 2
""",
"""
def ap_sum(a, d, n):
    return n*((2*a)+(n-1)*d)//2
"""
]

# =========================
# Problem 7: extract_elements
# =========================
extract_elements_solutions = [
"""
def extract_elements(lst, n):
    return [lst[i:i+n] for i in range(len(lst) - n + 1)]
""",
"""
def extract_elements(lst, n):
    res = []
    for i in range(0, len(lst) - n + 1):
        res.append(lst[i:i+n])
    return res
""",
"""
def extract_elements(lst, n):
    return list(map(lambda i: lst[i:i+n], range(len(lst) - n + 1)))
""",
"""
def extract_elements(lst, n):
    i, out = 0, []
    while i + n <= len(lst):
        out.append(lst[i:i+n])
        i += 1
    return out
""",
"""
def extract_elements(lst, n):
    return [lst[x:x+n] for x in range(len(lst)-n+1)]
"""
]

# =========================
# Problem 8: lcopy
# =========================
lcopy_solutions = [
"""
def lcopy(tup):
    return list(tup[0])
""",
"""
def lcopy(tup):
    [l] = tup
    return l.copy()
""",
"""
def lcopy(tup):
    return [*tup[0]]
""",
"""
def lcopy(tup):
    return list(tup)[0]
""",
"""
def lcopy(tup):
    return list(tup[0][:])
"""
]

# =========================
# Problem 9: largest_pos
# =========================
largest_pos_solutions = [
"""
def largest_pos(lst):
    pos = [x for x in lst if x > 0]
    return max(pos) if pos else None
""",
"""
def largest_pos(lst):
    res = None
    for x in lst:
        if x > 0 and (res is None or x > res):
            res = x
    return res
""",
"""
def largest_pos(lst):
    return max((x for x in lst if x > 0), default=None)
""",
"""
def largest_pos(lst):
    positives = filter(lambda x: x > 0, lst)
    return max(positives, default=None)
""",
"""
def largest_pos(lst):
    lst2=[x for x in lst if x>0]
    return max(lst2) if lst2 else None
"""
]

# =========================
# Problem 10: min_sum_path
# =========================
min_sum_path_solutions = [
"""
def min_sum_path(triangle):
    dp = triangle[-1][:]
    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])
    return dp[0]
""",
"""
def min_sum_path(triangle):
    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
    return triangle[0][0]
""",
"""
def min_sum_path(triangle):
    dp = [row[:] for row in triangle]
    for i in range(len(dp) - 2, -1, -1):
        dp[i] = [dp[i][j] + min(dp[i+1][j], dp[i+1][j+1]) for j in range(len(dp[i]))]
    return dp[0][0]
""",
"""
def min_sum_path(triangle):
    res = triangle[-1][:]
    for i in reversed(range(len(triangle) - 1)):
        res = [triangle[i][j] + min(res[j], res[j+1]) for j in range(len(triangle[i]))]
    return res[0]
""",
"""
def min_sum_path(triangle):
    import copy
    dp = copy.deepcopy(triangle)
    for i in range(len(dp)-2,-1,-1):
        for j in range(len(dp[i])):
            dp[i][j]+=min(dp[i+1][j],dp[i+1][j+1])
    return dp[0][0]
"""
]


**codes generated by GEMINI - Chain of Thoght**

# ==============================================================================
# All solutions in these lists use the same function name for their respective
# problem, making them interchangeable for testing purposes.
# ==============================================================================

# ==============================================================================
# Problem 1: Sum of fifth power of first n odd natural numbers
# Function Name: odd_Num_Sum
# ==============================================================================
odd_Num_Sum_solutions = [
# S1: Iterative for loop
"""def odd_Num_Sum(n):
    if not isinstance(n, int) or n < 1:
        return 0
    total_sum = 0
    for k in range(1, n + 1):
        odd_num = 2 * k - 1
        total_sum += odd_num ** 5
    return total_sum""",
# S2: while loop
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    total_sum = 0
    i = 1
    current_odd = 1
    while i <= n:
        total_sum += current_odd ** 5
        current_odd += 2
        i += 1
    return total_sum""",
# S3: List comprehension + sum
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    return sum([(2 * k - 1) ** 5 for k in range(1, n + 1)])""",
# S4: Generator expression + sum
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    return sum((pow(2 * k - 1, 5) for k in range(1, n + 1)))""",
# S5: functools.reduce
"""from functools import reduce
def odd_Num_Sum(n):
    if n <= 0:
        return 0
    odd_powers = (pow(2 * k - 1, 5) for k in range(1, n + 1))
    return reduce(lambda acc, x: acc + x, odd_powers, 0)"""
]

# ==============================================================================
# Problem 2: Calculate electricity bill
# Function Name: cal_electbill
# ==============================================================================
cal_electbill_solutions = [
# S1: Iterative slab check
"""def cal_electbill(units):
    if units <= 0:
        return 50.0
    fixed_charge = 50.0
    bill = fixed_charge
    remaining_units = units
    if remaining_units > 100:
        bill += 100 * 5.00
        remaining_units -= 100
    else:
        bill += remaining_units * 5.00
        return bill
    if remaining_units > 200:
        bill += 200 * 7.00
        remaining_units -= 200
    else:
        bill += remaining_units * 7.00
        return bill
    bill += remaining_units * 9.00
    return bill""",
# S2: clear if/elif structure
"""def cal_electbill(units):
    if units <= 0:
        return 50.0
    fixed_charge = 50.0
    bill = fixed_charge
    if units <= 100:
        bill += units * 5.0
    elif units <= 300:
        bill += 100 * 5.0
        bill += (units - 100) * 7.0
    else:
        bill += 100 * 5.0
        bill += 200 * 7.0
        bill += (units - 300) * 9.0
    return bill""",
# S3: Using list of slabs for calculation
"""def cal_electbill(units):
    if units <= 0:
        return 50.0
    fixed_charge = 50.0
    bill = fixed_charge
    slabs = [
        (100, 5.00, 0),
        (300, 7.00, 100),
        (float('inf'), 9.00, 300)
    ]
    remaining_units = units
    for limit, rate, prev_limit in slabs:
        if remaining_units > 0:
            slab_width = limit - prev_limit
            if units <= limit:
                units_in_slab = remaining_units
                bill += units_in_slab * rate
                remaining_units = 0
            else:
                bill += slab_width * rate
                remaining_units -= slab_width
        else:
            break
    return bill""",
# S4: Using remaining units calculation (top-down)
"""def cal_electbill(units):
    if units <= 0:
        return 50.0
    fixed_charge = 50.0
    bill = fixed_charge
    u = units
    if u > 300:
        slab3_units = u - 300
        bill += slab3_units * 9.00
        u = 300
    if u > 100:
        slab2_units = u - 100
        bill += slab2_units * 7.00
        u = 100
    if u > 0:
        slab1_units = u
        bill += slab1_units * 5.00
    return bill""",
# S5: Functional decomposition (min usage)
"""def cal_electbill(units):
    if units <= 0:
        return 50.0
    fixed_charge = 50.0
    bill = fixed_charge
    slab1_units = min(units, 100)
    bill += slab1_units * 5.0
    units -= slab1_units
    if units > 0:
        slab2_limit = 200
        slab2_units = min(units, slab2_limit)
        bill += slab2_units * 7.0
        units -= slab2_units
    if units > 0:
        bill += units * 9.0
    return bill"""
]

# ==============================================================================
# Problem 3: Check if a given number is one less than twice its reverse
# Function Name: check
# ==============================================================================
check_solutions = [
# S1: String slicing reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False
    n_str = str(n)
    n_reverse_str = n_str[::-1]
    try:
        n_reverse = int(n_reverse_str)
    except ValueError:
        return False
    return n == (2 * n_reverse) - 1""",
# S2: Standard string conversion
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False
    n_str = str(n)
    rev_str = n_str[::-1]
    try:
        n_rev = int(rev_str)
    except ValueError:
        return False
    return n == (2 * n_rev) - 1""",
# S3: Mathematical reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False
    original_n = n
    reversed_n = 0
    temp_n = n
    while temp_n > 0:
        digit = temp_n % 10
        reversed_n = (reversed_n * 10) + digit
        temp_n //= 10
    return original_n == (2 * reversed_n) - 1""",
# S4: Using map/join for reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False
    n_str = str(n)
    rev_str = "".join(reversed(n_str))
    try:
        n_rev = int(rev_str)
    except ValueError:
        return False
    return n == (2 * n_rev) - 1""",
# S5: Recursive reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False
    def reverse_recursive(num, reversed_val=0):
        if num == 0:
            return reversed_val
        last_digit = num % 10
        new_reversed = (reversed_val * 10) + last_digit
        return reverse_recursive(num // 10, new_reversed)
    n_rev = reverse_recursive(n)
    return n == (2 * n_rev) - 1"""
]

# ==============================================================================
# Problem 4: Iterate over elements repeating each as many times as its count
# Function Name: count_variable
# ==============================================================================
count_variable_solutions = [
# S1: Canonical Counter approach (loop)
"""from collections import Counter
def count_variable(data):
    counts = Counter(data)
    final_output = []
    for element, count in counts.items():
        final_output.extend([element] * count)
    return final_output""",
# S2: Canonical Counter approach (same as S1)
"""from collections import Counter
def count_variable(data):
    counts = Counter(data)
    result = []
    for item, count in counts.items():
        result.extend([item] * count)
    return result""",
# S3: List.count() - less efficient, preserves first appearance order
"""def count_variable(data):
    result = []
    seen = set()
    for item in data:
        if item not in seen:
            count = data.count(item)
            result.extend([item] * count)
            seen.add(item)
    return result""",
# S4: Functional approach with chain
"""from collections import Counter
from itertools import chain
def count_variable(data):
    counts = Counter(data)
    item_iterables = ([item] * count for item, count in counts.items())
    return list(chain.from_iterable(item_iterables))""",
# S5: Manual iteration with defaultdict
"""from collections import defaultdict
def count_variable(data):
    counts = defaultdict(int)
    for item in data:
        counts[item] += 1
    result = []
    for item, count in counts.items():
        result.extend([item] * count)
    return result"""
]

# ==============================================================================
# Problem 5: Find tuples which have all elements divisible by k
# Function Name: find_tuples
# ==============================================================================
find_tuples_solutions = [
# S1: Loop with 'all'
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    result = []
    for tup in list_of_tuples:
        if all(element % k == 0 for element in tup):
            result.append(tup)
    return result""",
# S2: List comprehension and 'all'
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    return [
        tup for tup in list_of_tuples
        if all(element % k == 0 for element in tup)
    ]""",
# S3: Traditional loop with flag
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    result = []
    for tup in list_of_tuples:
        is_divisible = True
        for element in tup:
            if element % k != 0:
                is_divisible = False
                break
        if is_divisible:
            result.append(tup)
    return result""",
# S4: Using filter and lambda
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    return list(filter(lambda tup: all(e % k == 0 for e in tup), list_of_tuples))""",
# S5: Using nested generator
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    return list(
        tup for tup in list_of_tuples
        if all(e % k == 0 for e in tup)
    )"""
]

# ==============================================================================
# Problem 6: Find the sum of arithmetic progression
# Function Name: ap_sum
# ==============================================================================
ap_sum_solutions = [
# S1: Standard formula S_n = n/2 * (2*a + (n-1)*d)
"""def ap_sum(a, n, d):
    if not isinstance(n, int) or n <= 0:
        return 0
    sum_n = (n / 2.0) * (2 * a + (n - 1) * d)
    return int(sum_n) if sum_n == int(sum_n) else sum_n""",
# S2: Using formula S_n = n/2 * (a + l)
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    last_term = a + (n - 1) * d
    sum_n = (n / 2.0) * (a + last_term)
    return int(sum_n) if sum_n == int(sum_n) else sum_n""",
# S3: Explicitly sum the terms in a loop
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    current_term = a
    total_sum = 0
    for _ in range(n):
        total_sum += current_term
        current_term += d
    return total_sum""",
# S4: Using sum() with a generator of terms
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    terms_generator = (a + i * d for i in range(n))
    return sum(terms_generator)""",
# S5: Formula using math module (cleaner implementation of formula)
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    numerator = n * (2 * a + (n - 1) * d)
    sum_n = numerator / 2.0
    return int(sum_n) if sum_n == int(sum_n) else sum_n"""
]

# ==============================================================================
# Problem 7: Extract specified number of elements continuously
# Function Name: extract_elements
# ==============================================================================
extract_elements_solutions = [
# S1: Standard range iteration and slicing (loop)
"""def extract_elements(lst, n):
    if n <= 0 or not lst or n > len(lst):
        return []
    result = []
    for i in range(len(lst) - n + 1):
        sub_list = lst[i : i + n]
        result.append(sub_list)
    return result""",
# S2: Standard slicing (list comprehension)
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    return [lst[i:i + n] for i in range(len(lst) - n + 1)]""",
# S3: Using list comprehension with explicit length check
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    return [
        lst[i:i+n]
        for i in range(len(lst))
        if i + n <= len(lst)
    ]""",
# S4: Using zip for sliding window
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    slices = (lst[i:] for i in range(n))
    return [list(tup) for tup in zip(*slices)]""",
# S5: Using slice and zip with index range
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    indices = range(len(lst) - n + 1)
    return [lst[i:i + n] for i in indices]"""
]

# ==============================================================================
# Problem 8: Copy a list from a singleton tuple
# Function Name: lcopy
# ==============================================================================
lcopy_solutions = [
# S1: list() constructor
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    copied_list = list(list_to_copy)
    return copied_list""",
# S2: Using slice copy tup[0][:]
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    copied_list = list_to_copy[:]
    return copied_list""",
# S3: Using copy.copy
"""from copy import copy as shallow_copy
def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    copied_list = shallow_copy(list_to_copy)
    return copied_list""",
# S4: Using list.copy() method
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    copied_list = list_to_copy.copy()
    return copied_list""",
# S5: Using tuple unpacking and list() constructor
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    try:
        (list_to_copy,) = tup
    except ValueError:
        return None
    if not isinstance(list_to_copy, list):
        return None
    copied_list = list(list_to_copy)
    return copied_list"""
]

# ==============================================================================
# Problem 9: Find the largest positive number from the given list
# Function Name: largest_pos
# ==============================================================================
largest_pos_solutions = [
# S1: Filter and max
"""def largest_pos(lst):
    positive_numbers = [x for x in lst if isinstance(x, (int, float)) and x > 0]
    if not positive_numbers:
        return None
    return max(positive_numbers)""",
# S2: Manual tracking loop
"""def largest_pos(lst):
    max_val = None
    found_positive = False
    for x in lst:
        if isinstance(x, (int, float)) and x > 0:
            if not found_positive or x > max_val:
                max_val = x
                found_positive = True
    return max_val""",
# S3: Filter with list comprehension, handled by try/except max
"""def largest_pos(lst):
    try:
        positive_numbers = [x for x in lst if isinstance(x, (int, float)) and x > 0]
        return max(positive_numbers)
    except ValueError:
        return None""",
# S4: Using max with default=None (Python 3.4+)
"""def largest_pos(lst):
    positive_numbers = [x for x in lst if isinstance(x, (int, float)) and x > 0]
    return max(positive_numbers, default=None)""",
# S5: Filter and then sort
"""def largest_pos(lst):
    positive_numbers = [x for x in lst if isinstance(x, (int, float)) and x > 0]
    if not positive_numbers:
        return None
    positive_numbers.sort()
    return positive_numbers[-1]"""
]

# ==============================================================================
# Problem 10: Find the minimum total path sum in the given triangle
# Function Name: min_sum_path
# ==============================================================================
min_sum_path_solutions = [
# S1: Bottom-Up DP modifying input list in place
"""def min_sum_path(triangle):
    if not triangle:
        return 0
    for row_index in range(len(triangle) - 2, -1, -1):
        current_row = triangle[row_index]
        next_row = triangle[row_index + 1]
        for col_index in range(len(current_row)):
            min_next = min(next_row[col_index], next_row[col_index + 1])
            current_row[col_index] += min_next
    return triangle[0][0]""",
# S2: DP, modifying an auxiliary array
"""def min_sum_path(triangle):
    if not triangle:
        return 0
    num_rows = len(triangle)
    dp = list(triangle[num_rows - 1])
    for i in range(num_rows - 2, -1, -1):
        current_row = triangle[i]
        new_dp = [0] * len(current_row)
        for j in range(len(current_row)):
            new_dp[j] = current_row[j] + min(dp[j], dp[j+1])
        dp = new_dp
    return dp[0]""",
# S3: Top-Down DP with Memoization - Recursive
"""def min_sum_path(triangle):
    if not triangle:
        return 0
    memo = {}
    def solve(r, c):
        if r == len(triangle) - 1:
            return triangle[r][c]
        if (r, c) in memo:
            return memo[(r, c)]
        current_val = triangle[r][c]
        down_left = solve(r + 1, c)
        down_right = solve(r + 1, c + 1)
        result = current_val + min(down_left, down_right)
        memo[(r, c)] = result
        return result
    return solve(0, 0)""",
# S4: Space-Optimized DP - Only uses one row
"""def min_sum_path(triangle):
    if not triangle:
        return 0
    dp_row = list(triangle[-1])
    for i in range(len(triangle) - 2, -1, -1):
        current_row = triangle[i]
        for j in range(len(current_row)):
            dp_row[j] = current_row[j] + min(dp_row[j], dp_row[j+1])
    return dp_row[0]""",
# S5: Bottom-Up DP modifying input list in place
"""def min_sum_path(triangle):
    if not triangle:
        return 0
    for row_idx in range(len(triangle) - 2, -1, -1):
        for col_idx in range(len(triangle[row_idx])):
            current_val = triangle[row_idx][col_idx]
            triangle[row_idx][col_idx] = current_val + min(
                triangle[row_idx + 1][col_idx],
                triangle[row_idx + 1][col_idx + 1]
            )
    return triangle[0][0]"""
]


**Codes generated by ChatGpt -- self plannig**

all_function_solutions = {
    "odd_Num_Sum": [
"""
def odd_Num_Sum(n):
    return sum((2 * i - 1) ** 5 for i in range(1, n + 1))
""",
"""
def odd_Num_Sum(n):
    total = 0
    for i in range(1, n * 2, 2):
        total += i ** 5
    return total
""",
"""
def odd_Num_Sum(n):
    return sum(pow(2*i-1, 5) for i in range(1, n+1))
""",
"""
def odd_Num_Sum(n):
    odds = [2*i-1 for i in range(1, n+1)]
    return sum(odds[i]**5 for i in range(n))
""",
"""
def odd_Num_Sum(n):
    return sum(map(lambda x: (2*x-1)**5, range(1,n+1)))
"""
    ],

    "cal_electbill": [
"""
def cal_electbill(units):
    if units <= 100:
        return units * 1.5
    elif units <= 200:
        return 100*1.5 + (units-100)*2.5
    elif units <= 500:
        return 100*1.5 + 100*2.5 + (units-200)*4
    else:
        return 100*1.5 + 100*2.5 + 300*4 + (units-500)*6
""",
"""
def cal_electbill(units):
    slabs=[(100,1.5),(100,2.5),(300,4),(float('inf'),6)]
    total=0
    for s,r in slabs:
        if units>s:
            total+=s*r
            units-=s
        else:
            total+=units*r
            break
    return total
""",
"""
def cal_electbill(units):
    bill=0
    if units>500:
        bill+=(units-500)*6
        units=500
    if units>200:
        bill+=(units-200)*4
        units=200
    if units>100:
        bill+=(units-100)*2.5
        units=100
    bill+=units*1.5
    return bill
""",
"""
def cal_electbill(units):
    t=[100,200,500]
    r=[1.5,2.5,4,6]
    if units<=t[0]: return units*r[0]
    elif units<=t[1]: return 100*r[0]+(units-100)*r[1]
    elif units<=t[2]: return 100*r[0]+100*r[1]+(units-200)*r[2]
    else: return 100*r[0]+100*r[1]+300*r[2]+(units-500)*r[3]
""",
"""
def cal_electbill(units):
    bill=0
    for u,r in [(100,1.5),(100,2.5),(300,4)]:
        if units>u:
            bill+=u*r
            units-=u
        else:
            bill+=units*r
            return bill
    bill+=units*6
    return bill
"""
    ],

    "check": [
"""
def check(num):
    rev=int(str(abs(num))[::-1])
    return num==2*rev-1
""",
"""
def check(num):
    return num+1==2*int(str(num)[::-1])
""",
"""
def check(num):
    s=str(num)
    r=int(s[::-1])
    return num==(2*r-1)
""",
"""
def check(num):
    rev=int(''.join(reversed(str(num))))
    return 2*rev-1==num
""",
"""
def check(num):
    return int(str(num)[::-1])*2-1==num
"""
    ],

    "count_variable": [
"""
from collections import Counter
def count_variable(lst):
    c=Counter(lst)
    res=[]
    for k,v in c.items():
        res.extend([k]*v)
    return res
""",
"""
def count_variable(lst):
    return [x for x in lst for _ in range(lst.count(x))]
""",
"""
def count_variable(lst):
    d={}
    for x in lst: d[x]=d.get(x,0)+1
    res=[]
    for k,v in d.items(): res+=[k]*v
    return res
""",
"""
def count_variable(lst):
    return sum(([x]*lst.count(x) for x in dict.fromkeys(lst)),[])
""",
"""
def count_variable(lst):
    from collections import Counter
    return [k for k,v in Counter(lst).items() for _ in range(v)]
"""
    ],

    "find_tuples": [
"""
def find_tuples(lst,k):
    return [t for t in lst if all(x%k==0 for x in t)]
""",
"""
def find_tuples(lst,k):
    res=[]
    for t in lst:
        if all(x%k==0 for x in t): res.append(t)
    return res
""",
"""
def find_tuples(lst,k):
    return list(filter(lambda t: all(x%k==0 for x in t), lst))
""",
"""
def find_tuples(lst,k):
    out=[]
    for t in lst:
        div=True
        for e in t:
            if e%k!=0: div=False; break
        if div: out.append(t)
    return out
""",
"""
def find_tuples(lst,k):
    return [t for t in lst if min(t)%k==0]
"""
    ],

    "ap_sum": [
"""
def ap_sum(a,d,n):
    return n*(2*a+(n-1)*d)//2
""",
"""
def ap_sum(a,d,n):
    total=0
    for i in range(n): total+=a+i*d
    return total
""",
"""
def ap_sum(a,d,n):
    return sum(a+i*d for i in range(n))
""",
"""
def ap_sum(a,d,n):
    last=a+(n-1)*d
    return n*(a+last)//2
""",
"""
def ap_sum(a,d,n):
    return n*((2*a)+(n-1)*d)//2
"""
    ],

    "extract_elements": [
"""
def extract_elements(lst,n):
    return [lst[i:i+n] for i in range(len(lst)-n+1)]
""",
"""
def extract_elements(lst,n):
    res=[]
    for i in range(len(lst)-n+1): res.append(lst[i:i+n])
    return res
""",
"""
def extract_elements(lst,n):
    return list(map(lambda i: lst[i:i+n], range(len(lst)-n+1)))
""",
"""
def extract_elements(lst,n):
    i,out=0,[]
    while i+n<=len(lst):
        out.append(lst[i:i+n])
        i+=1
    return out
""",
"""
def extract_elements(lst,n):
    return [lst[x:x+n] for x in range(len(lst)-n+1)]
"""
    ],

    "lcopy": [
"""
def lcopy(tup):
    return list(tup[0])
""",
"""
def lcopy(tup):
    [l]=tup
    return l.copy()
""",
"""
def lcopy(tup):
    return [*tup[0]]
""",
"""
def lcopy(tup):
    return list(tup)[0]
""",
"""
def lcopy(tup):
    return list(tup[0][:])
"""
    ],

    "largest_pos": [
"""
def largest_pos(lst):
    pos=[x for x in lst if x>0]
    return max(pos) if pos else None
""",
"""
def largest_pos(lst):
    res=None
    for x in lst:
        if x>0 and (res is None or x>res): res=x
    return res
""",
"""
def largest_pos(lst):
    return max((x for x in lst if x>0), default=None)
""",
"""
def largest_pos(lst):
    pos=filter(lambda x:x>0,lst)
    return max(pos, default=None)
""",
"""
def largest_pos(lst):
    p=[x for x in lst if x>0]
    return max(p) if p else None
"""
    ],

    "min_sum_path": [
"""
def min_sum_path(triangle):
    dp=triangle[-1][:]
    for i in range(len(triangle)-2,-1,-1):
        for j in range(len(triangle[i])):
            dp[j]=triangle[i][j]+min(dp[j],dp[j+1])
    return dp[0]
""",
"""
def min_sum_path(triangle):
    for i in range(len(triangle)-2,-1,-1):
        for j in range(len(triangle[i])):
            triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1])
    return triangle[0][0]
""",
"""
def min_sum_path(triangle):
    dp=[row[:] for row in triangle]
    for i in range(len(dp)-2,-1,-1):
        dp[i]=[dp[i][j]+min(dp[i+1][j],dp[i+1][j+1]) for j in range(len(dp[i]))]
    return dp[0][0]
""",
"""
def min_sum_path(triangle):
    res=triangle[-1][:]
    for i in reversed(range(len(triangle)-1)):
        res=[triangle[i][j]+min(res[j],res[j+1]) for j in range(len(triangle[i]))]
    return res[0]
""",
"""
def min_sum_path(triangle):
    import copy
    dp=copy.deepcopy(triangle)
    for i in range(len(dp)-2,-1,-1):
        for j in range(len(dp[i])):
            dp[i][j]+=min(dp[i+1][j],dp[i+1][j+1])
    return dp[0][0]
"""
    ]
}


**Codes generated by GEMINI 2.5 Flash ---- Self Plannig**

# ==============================================================================
# Problem 1: Sum of fifth power of first n odd natural numbers
# Function Name: odd_Num_Sum
# ==============================================================================
odd_Num_Sum_solutions = [
# S1: Iterative for loop
"""def odd_Num_Sum(n):
    if not isinstance(n, int) or n < 1:
        return 0
    total_sum = 0
    for k in range(1, n + 1):
        odd_num = 2 * k - 1
        total_sum += odd_num ** 5
    return total_sum""",
# S2: Functional with sum() and list comprehension
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    # Generate the list of odd numbers (1, 3, 5, ...) up to the nth term
    odd_powers = [(2 * k - 1) ** 5 for k in range(1, n + 1)]
    return sum(odd_powers)""",
# S3: Generator expression (more memory efficient than S2 for large n)
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    return sum((pow(2 * k - 1, 5) for k in range(1, n + 1)))""",
# S4: while loop implementation
"""def odd_Num_Sum(n):
    if n <= 0:
        return 0
    total_sum = 0
    i = 1  # Loop counter
    current_odd = 1
    while i <= n:
        total_sum += current_odd ** 5
        current_odd += 2 # Move to next odd number
        i += 1
    return total_sum""",
# S5: Using functools.reduce
"""from functools import reduce
def odd_Num_Sum(n):
    if n <= 0:
        return 0
    odd_powers_generator = (pow(2 * k - 1, 5) for k in range(1, n + 1))
    return reduce(lambda acc, x: acc + x, odd_powers_generator, 0)"""
]

# ==============================================================================
# Problem 2: Calculate electricity bill (using assumed fixed rates)
# Function Name: cal_electbill
# ==============================================================================
cal_electbill_solutions = [
# S1: Cascading if/elif/else structure (Top-Down unit subtraction)
"""def cal_electbill(units):
    if units <= 0:
        return 50.0 # Fixed charge only
    fixed_charge = 50.0
    bill = fixed_charge
    u = units

    # Slab 3: Above 300 @ $9.00
    if u > 300:
        slab3_units = u - 300
        bill += slab3_units * 9.00
        u = 300

    # Slab 2: 101-300 @ $7.00 (Max 200 units)
    if u > 100:
        slab2_units = u - 100
        bill += slab2_units * 7.00
        u = 100

    # Slab 1: 0-100 @ $5.00
    if u > 0:
        bill += u * 5.00

    return bill""",
# S2: Clear functional decomposition using min()
"""def cal_electbill(units):
    if units <= 0:
        return 50.0

    fixed_charge = 50.0
    bill = fixed_charge

    # Slab 1: 0-100 @ 5.0
    slab1_units = min(units, 100)
    bill += slab1_units * 5.0
    units -= slab1_units

    # Slab 2: 101-300 @ 7.0
    if units > 0:
        slab2_units = min(units, 200)
        bill += slab2_units * 7.0
        units -= slab2_units

    # Slab 3: >300 @ 9.0
    if units > 0:
        bill += units * 9.0

    return bill""",
# S3: Iterating over a defined list of slabs
"""def cal_electbill(units):
    if units <= 0:
        return 50.0

    # (max_units_in_slab, rate_per_unit)
    slabs = [(100, 5.00), (200, 7.00), (float('inf'), 9.00)]

    bill = 50.0 # Fixed Charge
    remaining_units = units

    for max_in_slab, rate in slabs:
        if remaining_units <= 0:
            break

        if max_in_slab == float('inf'):
            units_to_charge = remaining_units
        else:
            units_to_charge = min(remaining_units, max_in_slab)

        bill += units_to_charge * rate
        remaining_units -= units_to_charge

    return bill""",
# S4: Simplified combined if/elif/else structure
"""def cal_electbill(units):
    if units <= 0:
        return 50.0

    bill = 50.0

    if units <= 100:
        bill += units * 5.0
    elif units <= 300:
        # 100 units at 5.0 + remaining at 7.0
        bill += 100 * 5.0
        bill += (units - 100) * 7.0
    else:
        # 100 units at 5.0 + 200 units at 7.0 + remaining at 9.0
        bill += 100 * 5.0
        bill += 200 * 7.0
        bill += (units - 300) * 9.0

    return bill""",
# S5: Mathematical approach using max and subtraction
"""def cal_electbill(units):
    if units <= 0:
        return 50.0

    bill = 50.0

    # Calculate costs for units > 300 at $9.00
    bill += max(0, units - 300) * 9.0

    # Calculate costs for units 101-300 at $7.00
    # The max(0, units - 100) is the total over 100.
    # We subtract max(0, units - 300) to only count the 101-300 block.
    slab2_units = max(0, units - 100) - max(0, units - 300)
    bill += slab2_units * 7.0

    # Calculate costs for units 0-100 at $5.00
    slab1_units = min(units, 100)
    bill += slab1_units * 5.0

    return bill"""
]

# ==============================================================================
# Problem 3: Check if a given number is one less than twice its reverse
# Function Name: check
# ==============================================================================
check_solutions = [
# S1: String slicing reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False

    n_str = str(n)
    n_reverse_str = n_str[::-1]

    try:
        n_reverse = int(n_reverse_str)
    except ValueError:
        return False

    return n == (2 * n_reverse) - 1""",
# S2: Mathematical reversal using a while loop
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False

    original_n = n
    reversed_n = 0
    temp_n = n

    while temp_n > 0:
        digit = temp_n % 10
        reversed_n = (reversed_n * 10) + digit
        temp_n //= 10

    return original_n == (2 * reversed_n) - 1""",
# S3: Using "".join(reversed())
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False

    n_str = str(n)
    rev_str = "".join(reversed(n_str))

    try:
        n_rev = int(rev_str)
    except ValueError:
        return False

    return n == (2 * n_rev) - 1""",
# S4: String conversion and f-string evaluation
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False

    s = str(n)
    s_rev = s[::-1]

    try:
        n_rev = int(s_rev)
    except ValueError:
        return False

    # The condition n + 1 = 2 * n_rev
    return (n + 1) == (2 * n_rev)""",
# S5: Recursive mathematical reversal
"""def check(n):
    if not isinstance(n, int) or n < 0:
        return False

    def reverse_recursive(num, reversed_val=0):
        if num == 0:
            return reversed_val
        last_digit = num % 10
        new_reversed = (reversed_val * 10) + last_digit
        return reverse_recursive(num // 10, new_reversed)

    n_rev = reverse_recursive(n)
    return n == (2 * n_rev) - 1"""
]

# ==============================================================================
# Problem 4: Iterate over elements repeating each as many times as its count
# Function Name: count_variable
# ==============================================================================
count_variable_solutions = [
# S1: Canonical Counter approach and list extension
"""from collections import Counter
def count_variable(data):
    # Counter maintains order of insertion from Python 3.7+
    counts = Counter(data)
    final_output = []
    for element, count in counts.items():
        final_output.extend([element] * count)
    return final_output""",
# S2: Manual dictionary counting and iteration
"""from collections import defaultdict
def count_variable(data):
    # Use a dictionary to count frequencies
    counts = defaultdict(int)
    for item in data:
        counts[item] += 1

    result = []
    # Use the original list to determine the order of unique elements
    seen = set()
    for item in data:
        if item not in seen:
            count = counts[item]
            result.extend([item] * count)
            seen.add(item)
    return result""",
# S3: Using itertools.chain.from_iterable
"""from collections import Counter
from itertools import chain
def count_variable(data):
    counts = Counter(data)
    # Generator creates iterables like [item, item, ...], one for each unique item
    item_iterables = ([item] * count for item, count in counts.items())
    # Flatten the iterables into a single list
    return list(chain.from_iterable(item_iterables))""",
# S4: Nested list comprehension using list.count() (Inefficient but distinct)
"""def count_variable(data):
    result = []
    seen = set()
    for item in data:
        if item not in seen:
            count = data.count(item)
            result.extend([item] * count)
            seen.add(item)
    return result""",
# S5: Using dictionary items and sort (if order preservation wasn't guaranteed)
"""from collections import Counter
def count_variable(data):
    counts = Counter(data)
    items = list(counts.items())

    # If the user expects a specific order (e.g., sorted by item value), use sort.
    # Assuming order by first appearance is preferred, but using list sort for distinction
    # If using list(counts.items()), the order is usually insertion order (3.7+)

    final_output = []
    for element, count in items:
        final_output.extend([element] * count)
    return final_output""",
]

# ==============================================================================
# Problem 5: Find tuples which have all elements divisible by k
# Function Name: find_tuples
# ==============================================================================
find_tuples_solutions = [
# S1: List comprehension using all()
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    return [
        tup for tup in list_of_tuples
        if all(element % k == 0 for element in tup)
    ]""",
# S2: Filter with a lambda and all()
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    return list(filter(lambda tup: all(e % k == 0 for e in tup), list_of_tuples))""",
# S3: Traditional nested loop with flag
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    result = []
    for tup in list_of_tuples:
        is_divisible = True
        for element in tup:
            if element % k != 0:
                is_divisible = False
                break
        if is_divisible:
            result.append(tup)
    return result""",
# S4: Using generator and list() creation
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    # Generator expression yields tuples that satisfy the condition
    divisible_tuples = (
        tup for tup in list_of_tuples
        if all(e % k == 0 for e in tup)
    )
    return list(divisible_tuples)""",
# S5: Iterative approach with early return optimization for inner loop
"""def find_tuples(list_of_tuples, k):
    if k == 0:
        return []
    result = []
    for tup in list_of_tuples:
        # Check all elements. Loop breaks and executes else if no break occurs.
        for element in tup:
            if element % k != 0:
                break
        else:
            # Executes if the inner loop completes without a break
            result.append(tup)
    return result""",
]

# ==============================================================================
# Problem 6: Find the sum of arithmetic progression
# Function Name: ap_sum
# ==============================================================================
ap_sum_solutions = [
# S1: Standard formula S_n = n/2 * (2*a + (n-1)*d)
"""def ap_sum(a, n, d):
    if not isinstance(n, int) or n <= 0:
        return 0
    # Use floating point division for accuracy, then check for integer result
    sum_n = (n / 2.0) * (2 * a + (n - 1) * d)
    return int(sum_n) if sum_n == int(sum_n) else sum_n""",
# S2: Formula using last term: S_n = n/2 * (a + l)
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    last_term = a + (n - 1) * d
    sum_n = (n / 2.0) * (a + last_term)
    return int(sum_n) if sum_n == int(sum_n) else sum_n""",
# S3: Explicit iterative summation
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    current_term = a
    total_sum = 0
    for _ in range(n):
        total_sum += current_term
        current_term += d
    return total_sum""",
# S4: Using sum() with a generator expression for the terms
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    # Generator yields the terms: a, a+d, a+2d, ...
    terms_generator = (a + i * d for i in range(n))
    return sum(terms_generator)""",
# S5: Recursive approach (less efficient, but distinct)
"""def ap_sum(a, n, d):
    if n <= 0:
        return 0
    if n == 1:
        return a
    # Sum of n terms is the sum of (n-1) terms plus the nth term
    nth_term = a + (n - 1) * d
    return ap_sum(a, n - 1, d) + nth_term""",
]

# ==============================================================================
# Problem 7: Extract specified number of elements continuously
# Function Name: extract_elements
# ==============================================================================
extract_elements_solutions = [
# S1: Standard list comprehension with slicing
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    max_start_index = len(lst) - n
    return [
        lst[i : i + n]
        for i in range(max_start_index + 1)
    ]""",
# S2: for loop with explicit slicing
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    result = []
    max_start_index = len(lst) - n
    for i in range(max_start_index + 1):
        sub_list = lst[i : i + n]
        result.append(sub_list)
    return result""",
# S3: Using the zip trick for sliding window
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []
    # Create n slices, each shifted by one element
    slices = (lst[i:] for i in range(n))
    # zip combines the first element of each slice, then the second, etc.
    return [list(tup) for tup in zip(*slices)]""",
# S4: Generator function (yield)
"""def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []

    def window_generator(data, size):
        for i in range(len(data) - size + 1):
            yield data[i:i + size]

    # Return as a list as the function signature implies a full list return
    return list(window_generator(lst, n))""",
# S5: Using itertools.islice (more complex, but a distinct approach)
"""from itertools import islice
def extract_elements(lst, n):
    if n <= 0 or n > len(lst):
        return []

    result = []
    data_iterator = iter(lst)

    # Create iterators for each starting position
    teed_iterators = [islice(data_iterator, i, None) for i in range(n)]

    # Use zip to combine the elements from each starting position
    # The length of the shortest iterator (the last one) determines the number of windows
    for window_tuple in zip(*teed_iterators):
        result.append(list(window_tuple))

    return result""",
]

# ==============================================================================
# Problem 8: Copy a list from a singleton tuple
# Function Name: lcopy
# ==============================================================================
lcopy_solutions = [
# S1: Slicing (shallow copy)
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    # Shallow copy via slicing
    copied_list = list_to_copy[:]
    return copied_list""",
# S2: list() constructor
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    # Shallow copy via list() constructor
    copied_list = list(list_to_copy)
    return copied_list""",
# S3: list.copy() method
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    # Shallow copy via .copy() method (Python 3+)
    copied_list = list_to_copy.copy()
    return copied_list""",
# S4: copy.copy() function
"""from copy import copy as shallow_copy
def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None
    list_to_copy = tup[0]
    if not isinstance(list_to_copy, list):
        return None
    # Shallow copy via copy module
    copied_list = shallow_copy(list_to_copy)
    return copied_list""",
# S5: Tuple unpacking and explicit checks
"""def lcopy(tup):
    if not isinstance(tup, tuple) or len(tup) != 1:
        return None

    # Unpack the singleton tuple
    (list_candidate,) = tup

    if not isinstance(list_candidate, list):
        return None

    # Use list() constructor for the shallow copy
    copied_list = list(list_candidate)
    return copied_list""",
]

# ==============================================================================
# Problem 9: Find the largest postive number from the given list
# Function Name: largest_pos
# ==============================================================================
largest_pos_solutions = [
# S1: Filter list comprehension, then max()
"""def largest_pos(lst):
    positive_numbers = [
        x for x in lst
        if isinstance(x, (int, float)) and x > 0
    ]
    if not positive_numbers:
        return None
    return max(positive_numbers)""",
# S2: max() with generator and default=None
"""def largest_pos(lst):
    # Generator yields positive numbers
    positive_gen = (
        x for x in lst
        if isinstance(x, (int, float)) and x > 0
    )
    # max() with default=None handles empty generator case
    return max(positive_gen, default=None)""",
# S3: Manual iterative tracking of maximum value
"""def largest_pos(lst):
    max_val = None
    found_positive = False
    for x in lst:
        if isinstance(x, (int, float)) and x > 0:
            if not found_positive or x > max_val:
                max_val = x
                found_positive = True
    return max_val""",
# S4: Filter function and list conversion
"""def largest_pos(lst):
    def is_positive_numeric(x):
        return isinstance(x, (int, float)) and x > 0

    positive_list = list(filter(is_positive_numeric, lst))

    if not positive_list:
        return None
    return max(positive_list)""",
# S5: Filter, then sort and return last element (least efficient, but distinct)
"""def largest_pos(lst):
    positive_numbers = [
        x for x in lst
        if isinstance(x, (int, float)) and x > 0
    ]
    if not positive_numbers:
        return None
    # Sort the list (O(N log N))
    positive_numbers.sort()
    return positive_numbers[-1]""",
]

# ==============================================================================
# Problem 10: Find the minimum total path sum in the given triangle
# Function Name: min_sum_path
# ==============================================================================
min_sum_path_solutions = [
# S1: Bottom-Up DP, modifying the input triangle in place
"""def min_sum_path(triangle):
    if not triangle:
        return 0

    # Iterate from the second-to-last row up to the top
    for r in range(len(triangle) - 2, -1, -1):
        for c in range(len(triangle[r])):
            # Update the current cell with the minimum of the two paths below it
            triangle[r][c] += min(triangle[r + 1][c], triangle[r + 1][c + 1])

    return triangle[0][0]""",
# S2: Bottom-Up DP, using a space-optimized 1D array
"""def min_sum_path(triangle):
    if not triangle:
        return 0

    # Initialize DP array with the last row
    dp_row = list(triangle[-1])

    # Iterate upwards from the second-to-last row
    for r in range(len(triangle) - 2, -1, -1):
        current_row = triangle[r]
        for c in range(len(current_row)):
            # Update DP[c] with the minimum path sum passing through T[r][c]
            dp_row[c] = current_row[c] + min(dp_row[c], dp_row[c+1])

    return dp_row[0]""",
# S3: Top-Down DP with recursion and memoization
"""def min_sum_path(triangle):
    if not triangle:
        return 0

    memo = {}

    def solve(r, c):
        # Base Case: Last row
        if r == len(triangle) - 1:
            return triangle[r][c]

        # Check Memoization
        if (r, c) in memo:
            return memo[(r, c)]

        # Recursive Step
        current_val = triangle[r][c]
        down_left = solve(r + 1, c)
        down_right = solve(r + 1, c + 1)

        result = current_val + min(down_left, down_right)
        memo[(r, c)] = result
        return result

    return solve(0, 0)""",
# S4: Bottom-Up DP using a full 2D array (for conceptual clarity)
"""def min_sum_path(triangle):
    if not triangle:
        return 0

    n = len(triangle)
    # Initialize DP table (same dimensions as triangle)
    dp = [[0] * (i + 1) for i in range(n)]
    dp[-1] = list(triangle[-1])

    # Iterate from the second-to-last row up to the top
    for r in range(n - 2, -1, -1):
        for c in range(len(triangle[r])):
            # The path through T[r][c] is T[r][c] + min(DP[r+1][c], DP[r+1][c+1])
            dp[r][c] = triangle[r][c] + min(dp[r+1][c], dp[r+1][c+1])

    return dp[0][0]""",
# S5: Iterative approach using current row calculation
"""def min_sum_path(triangle):
    if not triangle:
        return 0

    # Create a mutable copy to avoid modifying the input triangle
    temp_triangle = [list(row) for row in triangle]

    # Start from the second-to-last row (index N-2)
    for r in range(len(temp_triangle) - 2, -1, -1):
        for c in range(len(temp_triangle[r])):
            temp_triangle[r][c] += min(
                temp_triangle[r + 1][c],
                temp_triangle[r + 1][c + 1]
            )

    return temp_triangle[0][0]"""
]


def fetch_random_problems(dataset_path, count=10, seed=101):
    
    df = pd.read_json(dataset_path, lines=True)
    subset = df.sample(count, random_state=seed)

    problems = []
    for _, record in subset.iterrows():
        problems.append({
            "task_id": record["task_id"],
            "description": record["text"],
            "func_name": record["entry_point"],
            "tests": record["test_list"],
            "reference_code": record["code"]
        })
    return problems

def show_task_overview(task_list):
    print("\n  Selected Evaluation Tasks")
    print("")
    for i, t in enumerate(task_list, 1):
        print(f"[{i:02d}] Task ID: {t['task_id']} | Function: {t['func']} | Tests: {len(t['tests'])}")
        print(f"      {t['desc'][:100].strip()}...")
    print("")


def run_code_evaluation(code_text, fn_name, test_cases):
    """
    Run a single function implementation against all test cases.
    """
    stats = {"passed": 0, "failed": 0, "total": len(test_cases)}

    try:
        env = {}
        exec(code_text, env)
        func = env.get(fn_name)
        if not callable(func):
            return stats

        for test in test_cases:
            try:
                sandbox = {fn_name: func, "__builtins__": {}}

                def safe_assert(cond, msg=None):
                    if not cond:
                        raise AssertionError(msg or "Test failed")
                sandbox["assert"] = safe_assert

                exec(test, sandbox)
                stats["passed"] += 1
            except Exception:
                stats["failed"] += 1
    except Exception:
        stats["failed"] = len(test_cases)

    return stats

def compute_pass_at_k(result_list, k=1):
    
    n = len(result_list)
    if n < k:
        return 0.0

    c = sum(r["passed"] == r["total"] for r in result_list)
    if n - c < k:
        return 1.0

    return 1 - comb(n - c, k) / comb(n, k)


def overall_accuracy(results):
    
    total, correct = 0, 0
    for r in results:
        total += r["total"]
        correct += r["passed"]

    return (correct / total) if total else 0.0

def evaluate_solutions(problem_set, solution_groups):
  
    evaluation_summary = []
    detailed_results = []

    print("\nEVALUATING SOLUTIONS")
    print("=" * 80)

    for i, problem in enumerate(problem_set):
        print(f"\nProblem {i + 1}: {problem['func_name']}")
        print(f"Description: {problem['description']}")

        if i >= len(solution_groups):
            print("No solutions provided for this problem.")
            continue

        results = []
        for j, code in enumerate(solution_groups[i]):
            res = run_code_evaluation(code, problem["func_name"], problem["tests"])
            results.append(res)
            detailed_results.append(res)
            print(f"  Variant {j + 1}: {res['passed']}/{res['total']} passed")

        p1 = compute_pass_at_k(results, 1)
        p3 = compute_pass_at_k(results, 3)
        p5 = compute_pass_at_k(results, 5)

        evaluation_summary.append({
            "problem_index": i + 1,
            "task_id": problem["task_id"],
            "function": problem["func_name"],
            "pass@1": p1,
            "pass@3": p3,
            "pass@5": p5,
            "tested_variants": len(results)
        })

        print(f"   pass@1={p1:.2f}, pass@3={p3:.2f}, pass@5={p5:.2f}")

    return evaluation_summary, detailed_results

def summarize_results(problem_metrics, test_results):
    """
    Print tabular and aggregate results.
    """
    print("\n" + "=" * 80)
    print("PASS@K METRICS SUMMARY")
    print("=" * 80)
    print(f"{'Problem':<8} {'Function':<20} {'pass@1':<8} {'pass@3':<8} {'pass@5':<8}")
    print("-" * 80)

    for r in problem_metrics:
        print(f"{r['problem_index']:<8} {r['function']:<20} "
              f"{r['pass@1']:<8.2f} {r['pass@3']:<8.2f} {r['pass@5']:<8.2f}")

    avg1 = np.mean([r["pass@1"] for r in problem_metrics])
    avg3 = np.mean([r["pass@3"] for r in problem_metrics])
    avg5 = np.mean([r["pass@5"] for r in problem_metrics])

    acc = overall_accuracy(test_results)
    total_solutions = len(test_results)
    perfect_solutions = sum(r["passed"] == r["total"] for r in test_results)

    print("-" * 80)
    print(f"{'AVERAGE':<8} {'':<20} {avg1:<8.2f} {avg3:<8.2f} {avg5:<8.2f}")

    print("\n" + "=" * 80)
    print("OVERALL SUCCESS STATS")
    print("=" * 80)
    print(f"Total Tests: {sum(r['total'] for r in test_results)}")
    print(f"Total Passed: {sum(r['passed'] for r in test_results)}")
    print(f"Overall Test Accuracy: {acc:.2%}")
    print(f"\nSolution Success Rate: {perfect_solutions / total_solutions:.2%}")
    print(f"  Perfect Solutions: {perfect_solutions}")
    print(f"  Partial Failures: {total_solutions - perfect_solutions}")
    print("=" * 80)

import pandas as pd
import numpy as np
from math import comb

if __name__ == "__main__":
    # Load problems
    dataset_path = "hf://datasets/dz1/CodeScore-MBPP-ET/MBPP_ET.jsonl"
    problems = fetch_random_problems(dataset_path)

    print_problem_summary(problems)

    all_solutions = [
        odd_Num_Sum_solutions,
        cal_electbill_solutions,
        check_solutions,
        count_variable_solutions,
        find_tuples_solutions,
        ap_sum_solutions,
        extract_elements_solutions,
        lcopy_solutions,
        largest_pos_solutions,
        min_sum_path_solutions,
    ]

    # Evaluate and summarize
    problem_results, test_results = evaluate_solutions(problems, all_solutions)
    summarize_results(problem_results, test_results)


